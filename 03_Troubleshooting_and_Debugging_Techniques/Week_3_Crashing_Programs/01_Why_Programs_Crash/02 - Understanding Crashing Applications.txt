- Understanding Crashing Applications:

When an application crashes and we don't know why, we'll want to look for logs 
that might relate to the failure. 

To look at logs on different systems:
- Linux: 
  Open the "system/log" files and "VAR/log" or the "user/log" files and
  ".xsession-errors" file. 
- MacOS: 
  "Console" app.
- Windows: "Event Viewer".

- What kind of data should you look for in these logs? 
Most logs have a date and time for each line logged, knowing when the 
application crashed, you can look for a log line around that time and try to 
find an error message related to the application that crashed. 

Sometimes the errors will be self-explanatory like:
- "Permission denied", 
- "No such file or directory",
- "Connection refused". 

Sometimes it will be a cryptic message and you have no idea what it means. 
Whenever we have an error message, no matter how weird it seems, we can search 
for it online to try to figure out its meaning. 
If we're lucky, we might find the official documentation of what that error 
means and what we can do about it. But if that's not available, we'll usually 
come across posts by others who have tackled a similar error and this 
additional information can help us understand what's going on. 

If there are no errors or the errors aren't useful, we can try to find out more 
info by enabling "debug logging". 
Many applications generate a lot more output when debug logging is enabled. 
We might need to enable it from a setting in the applications configuration 
file or a command line parameter to pass when running the application manually. 

By enabling this extra logging information, we can get a better idea of what's 
actually causing the problem. 

- What do we need to do if there are no logs or error messages at all? 
In that case we need to use tools that let us see what going on inside the 
program. 
To see system calls by OS:
- Linux:
  "strace"
- MacOS:
  "dtruss"
- Windows:
  "Process Monitor"

By tracing which system calls a program is doing we can see what files and 
directories it's trying open, what network connections it's trying to make and 
what information it's trying to read or write. 
This can give us a better idea of what caused the actual problem. 

We could find that the problem is caused by a resource not being present that 
the program expects to be present, like we saw with the missing directory 
example in the earlier module or we could find that the program tries to 
interact with the graphics interface and there isn't any, because it's a 
service running on a server. 
Or the program tries to open a file but the user running the software doesn't 
have the necessary permissions. 

If the application used to work fine and recently started crashing. It's useful 
to look into what changed in between. 
The first thing is to check if the issue is caused by a new version of the 
application itself. 
Maybe there's a bug in the new version that causes the crash or maybe the way 
that we're using the application is no longer supported. 
But that's not the only possible change that could trigger crashes.
It could also be that a library or service used by our application changed and 
they no longer work well together or it could be that there was a configuration 
change in the overall environment. 

Like if the user isn't in a specific group anymore or if the files that the 
application used are in a different location. 

When trying to figure out what changed, logs can also be a useful source of 
information. 
In the system log we can check which programs and libraries were recently 
updated checking for configuration changes might be harder depending on how you 
manage that configuration. 
If the settings are managed through a configuration management system and the 
values are stored in a Version Control System. Then you might be able to look 
at the history of changes and figure out which one triggered the failure. 

We call that a few times already how important it is to have a reproduction 
case for a problem that we're trying to solve. 
When we're trying to debug an application that crashes finding a reproduction 
case can help us both understand what's causing the crash and figure out what 
we can do to fix it. 
So it's valuable to spend some time figuring out the state that triggers the 
crash. This includes the overall system environment the specific application 
configuration, the inputs to the application, the outputs generated by the 
application, the resources that uses and the services it communicates with.

When trying create the reproduction case, it might be useful to start from a 
clean slate and slowly put the pieces in place until the crash triggers. 

This might include trying out the application with the default configuration 
instead of the local one or on a freshly installed computer instead of the 
computer where it's crashing. 
And remember, we want to make the reproduction case as small as possible. 
This lets us better understand the problem and also quickly check if its 
present or not when we attempt to fix it. 
And even if we end up unable to fix the issue, having a small and simple 
reproduction case is extremely helpful in reporting a bug to the program's 
developers. 

To sum this up, 
"""
To find the root cause of a crashing application we'll want to look at all 
available logs, figure out what changed, trace the system or library calls the 
program makes and create the smallest possible reproduction case.
"""

After doing all of this, we should have some idea of what the root cause of the 
issue is and maybe even how to fix it.

The strategy for fixing problems will depend on whether we can fix the code or 
not.