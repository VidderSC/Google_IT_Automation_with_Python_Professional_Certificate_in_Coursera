- Debugging a Segmentation Fault:

Let's check out what a segmentation fault looks like in action. 
We have a simple example program that crashes with a seg fault:

"""
user@ubuntu:~/example_coredump$ ./example
Segmentation fault
"""

When an application crashes like this, it's useful to have a "core file" of the 
crash.

- Core Files:
Store all the information related to the crash so that we, or someone else, can
debug what's going on.

It's like taking a snapshot of the crash when it happens to analyze it later. 
We need to tell the OS that we want to generate those core files. On Linux we 
use the "ulimit" command, then using the "-c" flag for "core files" and then "unlimited" to state that we want "core files" of any size.

"""
user@ubuntu:~/example_coredump$ ulimit -c unlimited
user@ubuntu:~/example_coredump$ ./example
Segmentation fault (core dumped)
"""

Our crashing program has generated a "core file". 
Let's check it out using LS -L:

"""
user@ubuntu:~/example_coredump$ ls -l core
-rw------- 1 user 380928 Jan  9 14:27 core
"""

This file contains all the information of what was going on with the program 
when it crashed. We can use it to understand why the program crashed by passing 
it to the "GDB" debugger. 
We'll call it "gdb -c core" to give it a "core file" and then "example" to tell 
it where the executable that crashed is located:

"""
user@ubuntu:~/example_coredump$ gdb -c core example
GNU gdb (Ubuntu 8.2.91.20190405-0ubuntu3) 8.2.91.20190405-git
Copyright (C) 2019 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later..
...
...
For help, type "help"
Type "apropos word" to search for commands related to "word"...
Reading symbols from example...
[New LWP 15422]
Core was generated by `./example'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  __strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-axv2.S:65
65      ../sysdeps/x86_64/multiarch/strlen-axv2.S: No such file or directory.
(gdb)
"""

When it starts, GDB shows a bunch of messages including its version, license, 
and how to get help. 
It then tells us that the program finished with a segmentation fault. 
It shows that the crash happened inside the strlen function in a file that's 
part of the system libraries. 
The "no such file or directory" error that we're seeing here means that we 
don't have the debugging symbols for that system library, but that's okay. 
We trust the "strlen" function to work correctly. 

It's our code that's buggy. Let's look at the full backtrace of the crash by 
using the backtrace command.

"""
...
Core was generated by `./example'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  __strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-axv2.S:65
65      ../sysdeps/x86_64/multiarch/strlen-axv2.S: No such file or directory.
(gdb) backtrace

#0  __strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-axv2.S:65
#1  0x0000558e723961b5 in copy_parameters (argc=1, argv=0x7fffcef4cd88) at example.c:10
#2  0x0000558e72396268 in main (argc=1, argv=0x7fffcef4cd88) at example.c:47
(gdb)
"""

The first element in the list is the function where the crash occurred. 
The second element is the function that called the function and so on. 
In this case, we see that the "strlen" function that failed was called by the 
"copy_parameters" function in our code which was called by the "main" function.

We can use the "up" command to move to the calling function in the backtrace 
and check out the line and copy parameters that caused the crash. 
We see that the faulty line is calling the "strlen" function, but it's not clear
why that would fail. 

"""
...
(gdb) up

#1  0x0000558e723961b5 in copy_parameters (argc=1, argv=0x7fffcef4cd88) at example.c:10
10              size_l len = strlen(argv[i]) + 1;
(gdb)
"""

We can get more contexts for the code that failed by calling the list command 
that shows the lines around the current one.

"""
...
(gdb) list

5
6       char** copy_parameters(int argc, char* argv[]) {
7           char **parameters = malloc(sizeof(char *) * argc);
8
9           for (int i = 0; i <= argc; i++) {
10              size_t len = strlen(argv[i]) + 1;
11              parameters[i] = malloc(len);
12              strncpy(parameters[i], argv[i], len);
13          }
14
(gdb)
"""

Here, we see a chunk of "C" code. 
If this is the first time you look at "C" code, it might seem a bit confusing. 
There are some similarities with "Python", but also, some things that are 
pretty different.

We see that the faulty line, "line 10", is in the body of a "for loop". 
The variable that the for loop uses to iterate is called "i". 

Let's check out the value of "i" using the print command:

"""
...
(gdb) print i
$i = 1
(gdb)
"""

GDB uses the dollar sign followed by a number to give separate identifiers to 
each result it prints. 
In this case, the result is "1". 
In other words, when the crash happened, "i" had the value of "1". 

Since this variable is being used to access an array called "argv", 
let's print the contents of the first element "argv[0]", and then the second 
element "argv[1]".

"""
...
(gdb) print argv[0]
$2 = 0x7fffcef4e32c "./example"
(gdb) print argv[1]
$3 = 0x0
(gdb)
"""

- What are those weird numbers starting with 0x? 
Those are hexadecimal numbers and they are used to show addresses in memory 
where some data is stored. 

Here, "GDB" is telling us that the first element in the argv array is a 
"pointer" pointing to the "./example" string. 

The second element is a "pointer" to zero "0", also known as a "null pointer".
"Zero" is never a valid pointer. 
It usually signals the end of data structures in C. So our code is trying to 
access the second element in the array, but the array only has one valid 
element. 

In other words, the "for loop" is doing one iteration too many. 
This is known as an "off-by-one" error, and it's a super common error. 

In this case, the fix is really simple. 
We need to change the less than or equal sign "<=" on line 9 to be a strictly
less than sign "<", so that the iteration stops one element before. 