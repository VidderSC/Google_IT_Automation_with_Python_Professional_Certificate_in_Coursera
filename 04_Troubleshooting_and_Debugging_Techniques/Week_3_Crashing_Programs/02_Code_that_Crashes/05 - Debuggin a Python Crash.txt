- Debugging a Python Crash:

In our last module, we looked into an application that was crashing with a 
segmentation fault. 
That kind of problem is common when dealing with applications written in 
languages like "C" or "C++". 
On the flip side, when using languages like "Python", we usually need to deal 
with unexpected exceptions making our program crash. 

- Example:
We have a script that updates the descriptions of some products in our 
company's database. It's a pretty simple script that takes a CSV file as a 
parameter, which includes the data that needs to be imported using the product 
code and description. Our script simply reads through a file and then updates 
the database. 

Most of the time it works just fine, but when the file with the new 
descriptions is generated by one specific user, the program fails with an 
exception. 
The user has sent us a file that's failing so that we can try to figure out 
what's going on.
Let's first check out the contents of the file:

"""
user@ubuntu:~/update_products$ cat new_products.csv
product_code,description
AV-101,Audio and Video converter 101 mm
SP-405,Sound Profiling 4.05 inches
TH-2,Tethering connector v2

"""

Okay, this seems harmless enough. Let's try executing the program:

"""
user@ubuntu:~/update_products$ ./update_products.py new_products.csv
Traceback (most recent call last):
  File "./update_products.py", line 59, in <module>
    sys.exit(main())
  File "./update_products.py", line 54, in main
    update_data(database, options)
  File "./update_products.py", line 42, in update_data
    row['product_code'], row['description']))
KeyError: 'product_code'
"""

The program failed with an exception. Let's have a look at this traceback to 
understand it a bit better:
At the bottom, we see the name of the exception. 
In this case, "KeyError" and the message in this case, "product_code", which is 
the name of the key that's failing. 
Above that, we see a list of function calls with two lines per function. 
- The first line tells us the Python file that contains the function, the line 
  number, and the name of the function. 
- The second line shows us the contents of that line. 

This information is similar to the backtrace that we saw in our last module, but
the order of the functions is reversed. 
The function at the bottom, "update_data", is the one where the exception 
occurred. 
Above it, we see that update data was called by main, and on top of that we see 
that main was called by the line at the module level. 

- So what's going on here? 
The update data function is trying to access the "product_code" fields in a 
variable named row. 
But for some reason this is failing with a "KeyError". 

Frequently, knowing the exception message and the line where the exception 
happened, is already enough to understand what's going on. But in some cases 
like this one, that's not enough. 
It's time to try our hand at using a Python debugger. 

We'll start the debugger by running "pdb3" and then passing the script that we 
want to run and any parameters that our script needs. 

In our case, we'll call: 

"""
user@ubuntu:~/update_products$ pdb3 update_products.py new_products.csv". 
> /home/user/update_products/update_products.py(2)<module>()
-> import argparse
(Pdb) _
"""

When we start the debugger it gets positioned at the first line of our script 
and waits for us to tell it what to do. 
We could run each of the instructions in the file one by one using the "next"
command, but there's a lot going on here, so we need to go through a lot of 
lines until we reach the failure. 

Alternatively, we can tell the debugger to "continue" the execution until it 
either finishes or crashes. Let's do that now:

"""
...
-> import argparse
(Pdb) continue
Traceback (most recent call last)
  File "/usr/lib/python3.7/pdb.py", line 1701, in main
    pdb._runscript(mainpyfile)
  File "/usr/lib/python3.7/pdb.py", line 1570, in _runscript
    self.run(statement)
  File "/usr/lib/python3.7/pdb.py", line 585, in run
    exec(cmd, globals, locals)
  File "<string>", line 1, in <module>
  File "/home/user/update_products/update_products.py", line 2, in <module>
    import argparse
  File "/home/user/update_products/update_products.py", line 54, in main
    update_data(database, options)
  File "/home/user/update_products/update_products.py", line 42, in update_data
    row['product_code'], row['description']))
KeyError: 'product_code'
Uncaught exception. Entering post mortem debugging
Running 'cont' or 'step' will restart the program
> /home/user/update_products/update_products.py(42)update_data()
-> row['product_code'], row['description']))
(Pdb) _
"""

So the program failed in the same way we'd seen before. But now we can use the 
debugger to get a better idea of why we're getting this pesky key error. 
Let's print the contents of row.

"""
...
-> row['product_code'], row['description']))
(Pdb) print(row)
OrderedDict([('\ufeffproduct_code', 'AV-101'), ('description', 'Audio and Video converter 101 mm')])
(Pdb) _
"""
That's really weird. 

- What are those characters appearing before product code? 
If we search online for the sequence of characters, will find that they 
represent the "Byte Order Mark" or "BOM" which is used in UTF-16 to tell the 
difference between a file stored using "Little-endian" and "Big-endian". 

Our file is in UTF-8 so it doesn't need the "BOM". But some programs still 
include it and this is tripping up our script. 

- So what can we do? 
Fortunately, others have already faced the same issue and figured out a 
solution. There is a special value called "utf-8-sig" that we can set as the 
encoding parameter of the "open" function. 

Setting this encoding means that "Python" will get rid of the "BOM" when files 
include it and behave as usual when they don't. 

Let's change the code of our script to use that encoding instead of the 
default. We'll look for the place where it's opening the file, then add the 
encoding parameter with "utf-8-sig" as the value.

"""
user@ubuntu:~/update_products$ atom update_products.py
"""

All right. We've made the change. 

- Will they work now? 
Let's check it out.

"""
user@ubuntu:~/update_products$ ./update_products.py new_products.csv
Updating AV-101 with value: Audio and Video converter 101 mm
Updating SP-405 with value: Sound Proofing 4.05 inches
Updating TH-2 with value: Tethering connector v2
Update Successful
"""

We've fixed the problem. Our script can now work with users generating files 
with and without the "Byte Order Mark". 


In the last two modules, we looked briefly at "GDB" and "PDB". 
We've barely discussed the surface of the many operations that we can do with 
debuggers. There are ton more advanced debugging features, like:
- Setting breakpoints. 
  They let the code run until certain line of code is executed.
- Watch points: 
  That let the code run until a variable or expression changes. 

We can also step through the code instruction by instruction to check when a 
problem happens and much more. We won't look into any of these advanced 
techniques here.